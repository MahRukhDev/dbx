{"version":3,"sources":["connectors.ts","photos/icons/file-icon.svg","ethereum/XENCrypto.js","ethereum/dbxen.js","components/App/Burn.tsx","ethereum/dbxenViews.js","ethereum/dbxenerc20.js","photos/icons/token.svg","photos/icons/coin-bag-solid--light.svg","photos/icons/coin-bag-solid--dark.svg","photos/icons/wallet--light.svg","photos/icons/wallet--dark.svg","photos/icons/fees.svg","photos/icons/finance.svg","ethereum/signer.js","ethereum/forwarder.js","components/App/Stake.tsx","components/Contexts/ThemeContext.tsx","components/Contexts/ThemeProvider.tsx","photos/icons/elephant.png","photos/icons/elephant.svg","photos/white_dbxen.svg","photos/empty.png","components/App/AppBar.tsx","photos/icons/copy-1.svg","photos/icons/wallet.svg","photos/icons/diconnect.svg","App.tsx","reportWebVitals.ts","index.tsx"],"names":["injected","InjectedConnector","supportedChainIds","network","NetworkConnector","urls","defaultChainId","require","abi","BigNumber","ethers","typeName","utils","id","dataFromWhitelist","whitelist","initialThemeState","theme","setTheme","_value","ThemeContext","createContext","ThemeProvider","children","useState","localStorage","window","useEffect","savedThemeLocal","getItem","setItem","Provider","value","className","ConnectorNames","Injected","process","REACT_APP_MAINTENANCE_MODE","Network","getLibrary","provider","library","providers","Web3Provider","pollingInterval","web3App","date","Date","UTC","now","endDate","getTime","renderer","hours","minutes","seconds","completed","ContractsDeployed","zeroPad","src","elephantWithText","alt","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oy2LASaA,EAAW,IAAIC,IAAkB,CAAEC,kBAAmB,CAAC,OAEvDC,EAAU,IAAIC,IAAiB,CACxCC,KAAM,CAAE,IANH,6EAOLC,eAAgB,M,kECbL,I,YCECC,EAAQ,KAAhBC,ICAQD,EAAQ,KAAhBC,I,cCScD,EAAQ,IAAtBE,U,+DCTQF,EAAQ,KAAhBC,ICAQD,EAAQ,KAAhBC,I,aCFO,ICAA,ICAA,ICAA,ICAA,ICAA,ICAA,ICAID,EAAQ,K,IAErBG,EAASH,EAAQ,IAKjBI,GAHiBJ,EAAQ,KAGjB,yBADS,oGAC0B,MAChCG,EAAOE,MAAMC,GAAGF,G,OCLjBJ,EAAQ,KAAhBC,I,oBCyBcM,EAAdC,UC1BD,IAAMC,EAAoB,CAC/BC,MAAO,OACPC,SAAU,SAACC,GAAoB,GAIlBC,EADMC,wBAAcL,GCwBpBM,EAxBO,SAAH,GAA+B,IAAxBC,EAAQ,EAARA,SACxB,EAA0BC,mBAAcR,EAAkBC,OAAM,mBAAzDA,EAAK,KAAEC,EAAQ,KAEhBO,EAAeC,OAAOD,aAc5B,OAZAE,qBAAU,WACR,IAAMC,EAAkBH,EAAaI,QAAQ,eAEvCD,GACJV,EAASU,EAEb,GAAG,CAACH,IAEJE,qBAAU,WACRF,EAAaK,QAAQ,cAAeb,EACtC,GAAG,CAACA,EAAOQ,IAGT,cAAC,EAAaM,SAAQ,CAACC,MAAO,CAAEf,QAAOC,YAAW,SAChD,qBAAKe,UAAS,uBAAkBhB,GAAQ,SAAEM,KAGhD,EC7Be,G,OCAA,IDAA,IAA0B,sCEA1B,ICAA,I,ICyBVW,E,qBCzBU,ICAA,ICAA,KHyBI,SAAdA,KAAc,qBAAdA,MAAc,KAE+C,eAC7DA,EAAeC,SAAWnC,G,MID1BkC,E,QAHeE,mIAAYC,4BAGb,SAAdH,KAAc,oBAAdA,EAAc,mBAAdA,MAAc,KAE+C,mBAC/DA,EAAeC,SAAWnC,GAAQ,cAClCkC,EAAeI,QAAUnC,GAG5B,SAASoC,EAAWC,GAClB,IAAMC,EAAU,IAAI/B,SAAOgC,UAAUC,aAAaH,GAGlD,OADAC,EAAQG,gBAAkB,KACnBH,CACT,CAEe,SAASI,IACpB,IAAMC,EAAW,IAAIC,KAAKA,KAAKC,IAAI,KAAM,EAAG,GAAI,GAAI,GAAI,EAAG,IACrDC,EAAWF,KAAKE,MAClBC,EAAUJ,EAAKK,UAAYF,EAEjC,OACM,cAAC,IAAiB,CAACV,WAAYA,EAAW,SACtC,cAAC,IAAS,CAACO,KAAMC,KAAKE,MAAQC,EAASE,SAAUA,KAI7D,CAEA,IAAMA,EAAW,SAAH,GAAqD,IAA/CC,EAAK,EAALA,MAAOC,EAAO,EAAPA,QAASC,EAAO,EAAPA,QAChC,OADkD,EAATC,UAGhC,cAACC,EAAiB,IAIvB,cAAC,EAAa,UACV,qBAAKxB,UAAU,qBAAoB,SAC/B,qBAAKA,UAAU,yBAAwB,SACnC,qBAAKA,UAAU,MAAK,SAChB,sBAAKA,UAAU,4BAA2B,UACtC,4BAAG,mBACH,8BACKyB,YAAQL,GAAO,IAAEK,YAAQJ,GAAS,IAAEI,YAAQH,gBAS7E,EAEA,SAASE,IACL,OACI,cAAC,EAAa,UACV,qBAAKxB,UAAU,qBAAoB,SAC/B,qBAAKA,UAAU,yBAAwB,SACnC,qBAAKA,UAAU,MAAK,SAChB,qBAAKA,UAAU,4BAA2B,SACtC,qBAAKA,UAAU,cAAc0B,IAAKC,EAAkBC,IAAI,sBAOpF,CC3FA,IAYeC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAAM,EAANA,OAAQC,EAAM,EAANA,OAAQC,EAAM,EAANA,OAAQC,EAAM,EAANA,OAAQC,EAAO,EAAPA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,EACV,GAEJ,E,OCLAQ,IAASC,OACP,cAAC,IAAMC,WAAU,UACf,cAAC,EAAG,MAENC,SAASC,eAAe,SAM1Bb,G","file":"static/js/main.312c0060.chunk.js","sourcesContent":["\nimport { InjectedConnector } from '@web3-react/injected-connector'\nimport { NetworkConnector } from '@web3-react/network-connector'\n\n// const POLLING_INTERVAL = 12000\nconst RPC_URLS: { [chainId: number]: string } = {\n    137: 'https://polygon-mainnet.g.alchemy.com/v2/qthz4_6kfuPquCG5N1A6v5Waz9YW0pNZ'\n}\n\nexport const injected = new InjectedConnector({ supportedChainIds: [137] })\n\nexport const network = new NetworkConnector({\n    urls: { 137: RPC_URLS[137] },\n    defaultChainId: 137\n  })","export default __webpack_public_path__ + \"static/media/file-icon.92106822.svg\";","import { ethers } from \"ethers\";\n\nconst { abi } = require(\"./XENCrypto.json\");\n\nexport default (signerOrProvider, address) => {\n    return new ethers.Contract(address, abi, signerOrProvider);\n}","import { ethers } from \"ethers\";\n\nconst { abi } = require(\"./DBXen.json\");\n\nexport default (signerOrProvider, address) => {\n  return new ethers.Contract(address, abi, signerOrProvider);\n}","import { useState, useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport XENCrypto from '../../ethereum/XENCrypto';\nimport DBXen from \"../../ethereum/dbxen\"\nimport { ethers } from \"ethers\";\nimport \"../../componentsStyling/permanentDrawer.scss\";\nimport SnackbarNotification from './Snackbar';\nimport LoadingButton from '@mui/lab/LoadingButton';\nimport { Spinner } from './Spinner';\nimport axios, { Method } from 'axios';\nimport web3 from 'web3';\nconst { BigNumber } = require(\"ethers\");\n\nconst deb0xAddress = \"0XBC7FB353CCEB4DCAD1DEA187BC443EACA3360B76\";\nconst xenCryptoAddress = \"0x2AB0e9e4eE70FFf1fB9D67031E44F6410170d00e\";\n\nexport function Burn(): any {\n    const context = useWeb3React()\n    const { library, account } = context\n    const [notificationState, setNotificationState] = useState({});\n    const [value, setValue] = useState(1);\n    const [approveBrun, setApproveBurn] = useState<boolean>();\n    const [balanceGratherThanZero, checkBalance] = useState(\"\");\n    const [maticValue, setMaticValue] = useState<any>();\n    const [totalCost, setTotalCost] = useState<any>();\n    const [totalAmountOfXEN, setXENAmount] = useState<any>();\n    const [loading, setLoading] = useState(false)\n\n    useEffect( () => {\n        setApproveBurn(false)\n    }, [account]);\n\n    useEffect( () => {\n        setApproveBurn(false);\n        getCurrentGasLimit().then(async (data) => {\n            estimationValue(data).then(async (resut) =>{\n            setMaticValue(resut.fee);\n            })\n        })\n    },[value]);\n\n    useEffect( () => {\n        setApproveBurn(false);\n        getCurrentGasLimit().then(async (data) => {\n            estimationValue(data).then(async (resut) =>{\n                setTotalCost(resut.total);\n            })\n        })\n    },[value]);\n\n    useEffect( () => {\n        setXENAmount(value*2500000);\n    },[value]);\n\n    useEffect(() => {\n        setBalance()\n    }, [account,balanceGratherThanZero]);\n\n    async function setBalance(){\n        setLoading(true);\n        const signer = await library.getSigner(0)\n        const xenContract = await XENCrypto(signer, xenCryptoAddress);\n        let number;\n\n        await xenContract.balanceOf(account).then((balance: any) => {\n            number = ethers.utils.formatEther(balance);\n            checkBalance(number.toString()) \n            setLoading(false);\n        })\n    }\n\n    async function getCurrentPrice(){\n        let method: Method = 'POST';\n        const options = {\n            method: method,\n            url: 'https://polygon-mainnet.infura.io/v3/6010818c577b4531b1886965421a91d3 ',\n            port: 443,\n            headers: {\n                'Content-Type': 'application/json'\n              },\n            data: JSON.stringify({\n                \"jsonrpc\":\"2.0\",\"method\":\"eth_gasPrice\",\"params\": [],\"id\":1\n              })\n        };\n\n        let requestValue = await axios.request(options)\n        return web3.utils.fromWei(requestValue.data.result.toString(), \"Gwei\")\n    }\n\n    async  function estimationValue(gasLimitIntervalValue: number){\n        let price = Number(await getCurrentPrice());\n        let protocol_fee = value *(1 - 0.00005*value) ;\n        let fee = gasLimitIntervalValue * price * protocol_fee / 1000000000;\n        let totalValue = fee +(fee /((1- 0.00005*value) * value));\n        let obj = {fee:fee.toFixed(4), total:totalValue.toFixed(4)}\n        return obj;\n    }\n    \n    async function getCurrentGasLimit(){\n        const signer = await library.getSigner(0)\n        const deb0xContract = DBXen(signer, deb0xAddress)\n        let currentCycle = await deb0xContract.getCurrentCycle();\n        let numberBatchesBurnedInCurrentCycle;\n        let batchBurned = 0;\n\n        numberBatchesBurnedInCurrentCycle = await deb0xContract.cycleTotalBatchesBurned(currentCycle);\n        batchBurned =numberBatchesBurnedInCurrentCycle.toNumber();\n        \n        let gasLimitIntervalValue;\n            if(batchBurned != 0)\n                gasLimitIntervalValue = BigNumber.from(\"130000\");\n                    else\n                gasLimitIntervalValue = BigNumber.from(\"400000\");\n        return gasLimitIntervalValue;\n    }\n\n    async function setApproval() {\n        setLoading(true);\n        const signer = await library.getSigner(0)\n        const xenContract = await XENCrypto(signer, xenCryptoAddress)\n        let totalAmountToBurn = value * 2500000;\n        try {\n            const tx = await xenContract.approve(deb0xAddress, ethers.utils.parseEther(totalAmountToBurn.toString()))\n            tx.wait()\n                .then((result: any) => {\n                    setApproveBurn(true);\n                    setNotificationState({\n                        message: \"Your succesfully approved contract for burn.\", open: true,\n                        severity: \"success\"\n                    })\n                    setLoading(false)\n                })\n                .catch((error: any) => {\n                    setNotificationState({\n                        message: \"Contract couldn't be approved for burn!\", open: true,\n                        severity: \"error\"\n                    })\n                    setLoading(false)\n                })\n        } catch (error) {\n            setNotificationState({\n                message: \"You rejected the transaction. Contract hasn't been approved for burn.\", open: true,\n                severity: \"info\"\n            })\n            setLoading(false)\n        }\n    }\n\n    async function burnXEN(){\n        setLoading(true)\n        const signer = await library.getSigner(0)\n        const deb0xContract = DBXen(signer, deb0xAddress)\n        let gasLimitIntervalValue = await getCurrentGasLimit();\n        let currentValue = (await estimationValue(gasLimitIntervalValue)).fee;\n        try {\n            const overrides = \n                { value: ethers.utils.parseUnits(currentValue.toString(), \"ether\"),\n                    gasLimit:gasLimitIntervalValue }\n            const tx = await deb0xContract[\"burnBatch(uint256)\"](value,overrides)\n\n            await tx.wait()\n                .then((result: any) => {\n                    setNotificationState({\n                        message: \"Burn completed\",\n                        open: true,\n                        severity: \"success\"\n                    })\n                    setLoading(false)\n                    setApproveBurn(false)\n                })\n                .catch((error: any) => {\n                    setNotificationState({\n                        message: \"Something went wrong!\",\n                        open: true,\n                        severity: \"error\"\n                    })\n                    setLoading(false)\n                })\n            } catch (error: any) {\n                console.log(error.message)\n                setNotificationState({\n                    message: \"You rejected the transaction.\",\n                    open: true,\n                    severity: \"info\"\n                })\n                setLoading(false)\n            }\n    }\n\n    useEffect(() => {\n        setTimeout(() => {setNotificationState({})}, 2000)\n    }, [notificationState])\n\n    const handleInputChange = (e: any)=>{\n        if(value > 10000) {\n            setValue(10000)\n        } else {\n            setValue(e.target.value);\n        }\n    }\n\n    const incNum = () => {\n        if(value < 10000)\n            setValue(Number(value)+1);\n    };\n\n    const decNum = () => {\n        if(value > 1)\n            setValue(value - 1);\n    }\n\n    useEffect(() => {\n        if (value > 10000) {\n            setValue(10000)\n        }\n        if (value <= 0 ) {\n            setValue(1)\n        }\n    }, [value])\n    \n    return (\n        <>\n            <SnackbarNotification state={notificationState} \n                    setNotificationState={setNotificationState} />\n            <div className=\"side-menu--bottom burn-container\">\n                <div className=\"row\">\n                    <p className=\"text-center mb-0\">Choose the number of XEN batches you want to burn</p>\n                    <p className=\"text-center\">(1 batch = 2 500 000 XEN)</p>\n                </div>\n                <div className=\"row\">\n                    <div className=\"col input-col\">\n                        <input type=\"number\" value={value} max=\"10000\" onChange={handleInputChange}/>\n                    </div>\n                </div>\n                <div className=\"row\">\n                    <button className=\"btn count-btn col\" type=\"button\" onClick={decNum}>-</button>\n                    <button className=\"btn count-btn col\" type=\"button\" onClick={incNum}>+</button>\n                </div>\n                <div className=\"row\">\n                    <button className=\"btn count-btn max-btn col\" type=\"button\" \n                        onClick={() => setValue(10000)}>MAX</button>\n                </div>\n                <div className=\"values-container\">\n                    <div className=\"value-content\">\n                        <p>Protocol Fee:</p>\n                        <p> ~{maticValue} MATIC</p>\n                    </div>\n                    <div className=\"value-content\">\n                        <p>Total transaction cost:</p>\n                        <p> ~{totalCost} MATIC</p>\n                    </div>\n                    <div className=\"value-content\">\n                        <p>Total XEN burned:</p>\n                        <p> {totalAmountOfXEN} XEN</p>\n                    </div>\n                </div>\n                {approveBrun ?\n                    <LoadingButton className=\"burn-btn\" \n                        loadingPosition=\"end\"\n                        onClick={() => burnXEN()} >\n                            {loading ? <Spinner color={'black'} /> : \"Burn XEN\" }\n                    </LoadingButton> :\n                    balanceGratherThanZero === '0.0' ||  balanceGratherThanZero === '0' ? \n                    <LoadingButton className=\"burn-btn\" \n                        loadingPosition=\"end\"\n                        disabled={ balanceGratherThanZero === '0.0' ||  balanceGratherThanZero === '0'}>\n                            {loading ? <Spinner color={'black'} /> : \"Your balance is 0!\" }\n                    </LoadingButton> :\n                    <LoadingButton className=\"burn-btn\" \n                        loadingPosition=\"end\"\n                        disabled={  balanceGratherThanZero === '0.0' ||  balanceGratherThanZero === '0'}\n                        onClick={() => setApproval()} >\n                            {loading ? <Spinner color={'black'} /> : \"Approve Burn XEN\" }\n                    </LoadingButton>\n                }\n            </div>\n        </>\n    )\n}\n","import { ethers } from \"ethers\";\n\nconst { abi } = require(\"./DBXenViews.json\");\n\nexport default (signerOrProvider, address) => {\n    return new ethers.Contract(address, abi, signerOrProvider);\n}","import { ethers } from \"ethers\";\n\nconst { abi } = require(\"./DBXenERC20.json\");\n\nexport default (signerOrProvider, address) => {\n    return new ethers.Contract(address, abi, signerOrProvider);\n}\n","export default __webpack_public_path__ + \"static/media/token.0bd78e9a.svg\";","export default __webpack_public_path__ + \"static/media/coin-bag-solid--light.d9344235.svg\";","export default __webpack_public_path__ + \"static/media/coin-bag-solid--dark.b9b74873.svg\";","export default __webpack_public_path__ + \"static/media/wallet--light.60fbc32b.svg\";","export default __webpack_public_path__ + \"static/media/wallet--dark.307c5384.svg\";","export default __webpack_public_path__ + \"static/media/fees.50cb4df6.svg\";","export default __webpack_public_path__ + \"static/media/finance.d8ebf4c0.svg\";","const ethSigUtil = require('eth-sig-util');\n\nconst ethers = require('ethers')\n\nconst ethereumJsUtil = require('ethereumjs-util')\n\nconst GENERIC_PARAMS = 'address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 validUntilTime'\nconst typeName = `ForwardRequest(${GENERIC_PARAMS})`\nconst typeHash = ethers.utils.id(typeName)\n\nconst EIP712Domain = [\n    { name: 'name', type: 'string' },\n    { name: 'version', type: 'string' },\n    { name: 'chainId', type: 'uint256' },\n    { name: 'verifyingContract', type: 'address' }\n];\n\nconst ForwardRequest = [\n    { name: 'from', type: 'address' },\n    { name: 'to', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'gas', type: 'uint256' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'data', type: 'bytes' },\n    { name: 'validUntilTime', type: 'uint256' }\n];\n\nfunction getMetaTxTypeData(chainId, verifyingContract) {\n    return {\n        types: {\n            EIP712Domain,\n            ForwardRequest,\n        },\n        domain: {\n            name: 'Forwarder',\n            version: '0.0.1',\n            chainId,\n            verifyingContract,\n        },\n        primaryType: 'ForwardRequest',\n    }\n};\n\nasync function signTypedData(signer, from, data) {\n    const [method, argData] = ['eth_signTypedData_v4', JSON.stringify(data)]\n    return await signer.send(method, [from, argData]);\n}\n\nasync function buildRequest(forwarder, input, valueParam) {\n    const value = valueParam ? valueParam : '0';\n    const nonce = await forwarder.getNonce(input.from).then(nonce => nonce.toString());\n    return { value, gas: '100000', nonce, validUntilTime: '0', ...input };\n}\n\nasync function buildTypedData(forwarder, request) {\n    const chainId = await forwarder.provider.getNetwork().then(n => n.chainId);\n    const typeData = getMetaTxTypeData(chainId, forwarder.address);\n    return {...typeData, message: request };\n}\n\nasync function getDomainSeparator(forwarder) {\n    const chainId = await forwarder.provider.getNetwork().then(n => n.chainId);\n    const typeData = getMetaTxTypeData(chainId, forwarder.address);\n    return ethereumJsUtil.bufferToHex(ethSigUtil.TypedDataUtils.hashStruct('EIP712Domain', typeData.domain, { EIP712Domain }, 'V4'))\n}\n\nexport async function signMetaTxRequest(signer, forwarder, input, value) {\n    const request = await buildRequest(forwarder, input, value);\n    const toSign = await buildTypedData(forwarder, request);\n    const signature = await signTypedData(signer, input.from, toSign);\n    const domainSeparator = await getDomainSeparator(forwarder)\n    return { typeHash, domainSeparator, signature, request };\n}","import { ethers } from 'ethers';\nimport { Forwarder as address } from '../deploy.json';\n\nconst { abi } = require(\"./Forwarder.json\");\n\nexport function createInstance(provider) {\n  return new ethers.Contract(address, abi, provider);\n}\n","import { useState, useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport {\n    Card, CardActions, CardContent, Button, Grid,\n    Typography, Box, OutlinedInput\n} from '@mui/material';\n\nimport ToggleButton from '@mui/material/ToggleButton';\nimport ToggleButtonGroup from '@mui/material/ToggleButtonGroup';\nimport LoadingButton from '@mui/lab/LoadingButton';\nimport DBXen from \"../../ethereum/dbxen\"\nimport DBXenViews from \"../../ethereum/dbxenViews\";\nimport DBXenERC20 from \"../../ethereum/dbxenerc20\"\nimport SnackbarNotification from './Snackbar';\nimport { BigNumber, ethers } from \"ethers\";\nimport \"../../componentsStyling/stake.scss\";\nimport token from \"../../photos/icons/token.svg\"\nimport coinBagLight from \"../../photos/icons/coin-bag-solid--light.svg\";\nimport coinBagDark from \"../../photos/icons/coin-bag-solid--dark.svg\";\nimport walletLight from \"../../photos/icons/wallet--light.svg\";\nimport walletDark from \"../../photos/icons/wallet--dark.svg\";\nimport fees from \"../../photos/icons/fees.svg\";\nimport finance from \"../../photos/icons/finance.svg\";\nimport { signMetaTxRequest } from '../../ethereum/signer';\nimport { createInstance } from '../../ethereum/forwarder'\nimport dataFromWhitelist from '../../constants.json';\nimport useAnalyticsEventTracker from '../Common/GaEventTracker';\n\nconst { whitelist } = dataFromWhitelist;\nconst deb0xAddress = \"0XBC7FB353CCEB4DCAD1DEA187BC443EACA3360B76\";\nconst deb0xViewsAddress = \"0X07F38CCDDC4ADE1D0EA6DC97AB0687470CC1CB15\";\nconst deb0xERC20Address = \"0X196383703B9910F38E25528858E67E63362AD68A\";\n\nexport function Stake(props: any): any {\n\n    const { account, library } = useWeb3React()\n    const [notificationState, setNotificationState] = useState({})\n    const gaEventTracker = useAnalyticsEventTracker('Stake');\n    const [previousCycleXENBurned, setPreviousCycleXENBurned] = useState<any>();\n\n    function FeesPanel() {\n        const [feesUnclaimed, setFeesUnclaimed] = useState(\"\")\n        const [loading, setLoading] = useState(false)\n\n        useEffect(() => {\n            feesAccrued()\n        }, [feesUnclaimed]);\n\n\n        useEffect(() => {\n            const totalXenBurnedPreviousCycle = async () =>{\n                setPreviousCycleXENBurned(await getTotalXenBurnedInPreviusCycle())\n            }\n            totalXenBurnedPreviousCycle();\n        },[]);\n    \n        async function getTotalXenBurnedInPreviusCycle(){\n            const signer = await library.getSigner(0)\n            const deb0xContract = DBXen(signer, deb0xAddress)\n            let currentCycle = await deb0xContract.getCurrentCycle();\n            if(currentCycle != 0){\n                 let numberBatchesBurnedInCurrentCycle = await deb0xContract.cycleTotalBatchesBurned(currentCycle);\n                 let batchBurned = numberBatchesBurnedInCurrentCycle.toNumber();\n                 return batchBurned * 2500000;\n            }\n            return 0;\n        }\n\n\n        async function feesAccrued() {\n            const deb0xViewsContract = await DBXenViews(library, deb0xViewsAddress);\n            \n            const unclaimedRewards = await deb0xViewsContract.getUnclaimedFees(account);\n\n            setFeesUnclaimed(ethers.utils.formatEther(unclaimedRewards))\n        }\n\n        async function fetchClaimFeesResult(request: any, url: any) {\n            await fetch(url, {\n                method: 'POST',\n                body: JSON.stringify(request),\n                headers: { 'Content-Type': 'application/json' },\n            })\n                .then((response) => response.json())\n                .then(async (data) => {\n                    try{\n                        const {tx: txReceipt} = JSON.parse(data.result)\n                        if(txReceipt.status == 1){\n                            setNotificationState({\n                                message: \"You succesfully claimed your fees.\", open: true,\n                                severity: \"success\"\n                            })\n                        } else {\n                            setNotificationState({\n                                message: \"Fees couldn't be claimed!\", open: true,\n                                severity: \"error\"\n                            })\n                            setLoading(false)\n                        }\n                    } catch(error) {\n                        if(data.status == \"pending\") {\n                            setNotificationState({\n                                message: \"Your transaction is pending. Your fees should arrive shortly\",\n                                open: true,\n                                severity: \"info\"\n                            })\n                        } else if(data.status == \"error\") {\n                            setNotificationState({\n                                message: \"Transaction relayer error. Please try again\",\n                                open: true,\n                                severity: \"error\"\n                            })\n                        }\n                    }\n                    \n                })\n        }\n\n        async function sendClaimFeesTx(deb0xContract: any) {\n            try {\n                const tx = await deb0xContract.claimFees()\n\n                tx.wait()\n                    .then((result: any) => {\n                        setNotificationState({\n                            message: \"You succesfully claimed your fees.\", open: true,\n                            severity: \"success\"\n                        })\n                        //setLoading(false)\n\n                    })\n                    .catch((error: any) => {\n                        setNotificationState({\n                            message: \"Fees couldn't be claimed!\", open: true,\n                            severity: \"error\"\n                        })\n                        setLoading(false)\n                    })\n            } catch (error: any) {\n                setNotificationState({\n                    message: \"You rejected the transaction. Your fees haven't been claimed.\",\n                    open: true,\n                    severity: \"info\"\n                })\n                setLoading(false)\n            }\n        }\n\n        async function claimFees() {\n            setLoading(true)\n\n            const signer = await library.getSigner(0)\n\n            const deb0xContract = DBXen(signer, deb0xAddress)\n\n            \n            const from = await signer.getAddress();\n            if(whitelist.includes(from)) {\n                const url = \"https://api.defender.openzeppelin.com/autotasks/b939da27-4a61-4464-8d7e-4b0c5dceb270/runs/webhook/f662ac31-8f56-4b4c-9526-35aea314af63/SPs6smVfv41kLtz4zivxr8\";\n                const forwarder = createInstance(library)\n                const data = deb0xContract.interface.encodeFunctionData(\"claimFees()\")\n                const to = deb0xContract.address\n\n                try {\n                    const request = await signMetaTxRequest(library, forwarder, { to, from, data });\n\n                    gaEventTracker(\"Success: Claim fees\");\n        \n                    await fetchClaimFeesResult(request, url)\n        \n                } catch (error: any) {\n                    setNotificationState({\n                        message: \"You rejected the transaction. Fees were not claimed.\",\n                        open: true,\n                        severity: \"info\"\n                    })\n\n                    gaEventTracker(\"Rejected: Claim fees\");\n                }\n            } else {\n                await sendClaimFeesTx(deb0xContract)\n            }\n        }\n\n        return (\n            <>\n            <Card variant=\"outlined\" className=\"card-container\">\n                <CardContent className=\"row\">\n                    <div className=\"col-12 col-md-8 mb-2\">\n                        <Typography variant=\"h4\" component=\"div\" className=\"rewards mb-3\">\n                            Your protocol fee share\n                        </Typography>\n                        <Typography >\n                            Your unclaimed MATIC fees: <strong>{feesUnclaimed}</strong>\n                        </Typography>\n                        <p className='my-2 counter'>\n                            Get next fees in:\n                        </p>\n                    </div>\n                    <div className='col-12 col-md-4 d-flex justify-content-end align-items-start'>\n                        <img src={fees} alt=\"trophyRewards\" className=\"p-3 medium-img\"/>\n                    </div>\n                </CardContent>\n                <CardActions className='button-container px-3'>\n                    <LoadingButton \n                        className=\"collect-btn\"\n                        disabled={feesUnclaimed==\"0.0\"}\n                        loading={loading}\n                        variant=\"contained\"\n                        onClick={claimFees}>\n                            Collect\n                    </LoadingButton>\n                </CardActions>\n            </Card>\n            </>\n        )\n    }\n\n    function CyclePanel() {\n        const [currentReward, setCurrentReward] = useState(\"\")\n        useEffect(() => {\n            cycleReward()\n        }, [currentReward]);\n        async function cycleReward() {\n            const deb0xContract = await DBXen(library, deb0xAddress);\n            const currentReward = await deb0xContract.currentCycleReward();\n            setCurrentReward(ethers.utils.formatEther(currentReward))\n        }\n        return (\n            <>\n            <Card variant=\"outlined\" className=\"card-container\">\n                <CardContent className=\"row\">\n                    <div className=\"col-12 col-md-12 mb-2\">\n                        <Typography variant=\"h4\" component=\"div\" className=\"rewards mb-3\">\n                            Daily stats\n                        </Typography>\n                        <Typography className=\"data-height\">\n                            This cycle mints: <strong>{Number(currentReward).toFixed(2)}</strong> DXN\n                        </Typography>\n                        {/* <Typography className=\"data-height\">\n                            Total XEN burned in previous cycle: <strong>{previousCycleXENBurned}</strong>\n                        </Typography> */}\n                    </div>\n                </CardContent>\n            </Card>\n            </>\n        )\n    }\n\n    function RewardsPanel() {\n        \n        const [rewardsUnclaimed, setRewardsUnclaimed] = useState(\"\")\n        const [feeSharePercentage, setFeeSharePercentage] = useState(\"\")\n        const [loading, setLoading] = useState(false)\n\n        useEffect(() => {\n            rewardsAccrued()\n        }, [rewardsUnclaimed]);\n\n        useEffect(() => {\n            feeShare()\n        }, [feeSharePercentage]);\n\n        async function rewardsAccrued() {\n            const deb0xViewsContract = await DBXenViews(library, deb0xViewsAddress);\n\n            const unclaimedRewards = await deb0xViewsContract.getUnclaimedRewards(account);\n         \n            setRewardsUnclaimed(ethers.utils.formatEther(unclaimedRewards))\n        }\n\n        async function feeShare() {\n            const deb0xViewsContract = await DBXenViews(library, deb0xViewsAddress);\n\n            const deb0xContract = await DBXen(library, deb0xAddress);\n\n            const unclaimedRewards = await deb0xViewsContract.getUnclaimedRewards(account);\n\n            const accWithdrawableStake = await deb0xViewsContract.getAccWithdrawableStake(account);\n            \n            let balance = parseFloat((ethers.utils.formatEther(unclaimedRewards.add(accWithdrawableStake))))\n            \n            const currentCycle = await deb0xContract.currentStartedCycle();\n\n            const totalSupply = await deb0xContract.summedCycleStakes(currentCycle);\n\n            const feeShare = balance * 100 / totalSupply\n            setFeeSharePercentage(((Math.round(feeShare * 100) / 100).toFixed(2)).toString() + \"%\")\n        }\n\n        async function fetchClaimRewardsResult(request: any, url: any) {\n            await fetch(url, {\n                method: 'POST',\n                body: JSON.stringify(request),\n                headers: { 'Content-Type': 'application/json' },\n            })\n                .then((response) => response.json())\n                .then(async (data) => {\n                    try{\n                        const {tx: txReceipt} = JSON.parse(data.result)\n                        if(txReceipt.status == 1){\n                            setNotificationState({\n                                message: \"You succesfully claimed your rewards.\", open: true,\n                                severity: \"success\"\n                            })\n                        } else {\n                            setNotificationState({\n                                message: \"Rewards couldn't be claimed!\", open: true,\n                                severity: \"error\"\n                            })\n                            setLoading(false)\n                        }\n                    } catch(error) {\n                        if(data.status == \"pending\") {\n                            setNotificationState({\n                                message: \"Your transaction is pending. Your rewards should arrive shortly\",\n                                open: true,\n                                severity: \"info\"\n                            })\n                        } else if(data.status == \"error\") {\n                            setNotificationState({\n                                message: \"Transaction relayer error. Please try again\",\n                                open: true,\n                                severity: \"error\"\n                            })\n                        }\n                    }\n                    \n                })\n        }\n\n        async function sendClaimRewardsTx(deb0xContract: any) {\n            try {\n                const tx = await deb0xContract.claimRewards()\n\n                tx.wait()\n                    .then((result: any) => {\n                        setNotificationState({\n                            message: \"You succesfully claimed your rewards.\", open: true,\n                            severity: \"success\"\n                        })\n                        //setLoading(false)\n\n                    })\n                    .catch((error: any) => {\n                        setNotificationState({\n                            message: \"Rewards couldn't be claimed!\", open: true,\n                            severity: \"error\"\n                        })\n                        setLoading(false)\n                    })\n            } catch (error: any) {\n                setNotificationState({\n                    message: \"You rejected the transaction. Your rewards haven't been claimed.\",\n                    open: true,\n                    severity: \"info\"\n                })\n                setLoading(false)\n            }\n        }\n\n        async function claimRewards() {\n            setLoading(true)\n\n            const signer = await library.getSigner(0)\n\n            const deb0xContract = DBXen(signer, deb0xAddress)\n\n            \n            const from = await signer.getAddress();\n            if(whitelist.includes(from)) {\n                const url = \"https://api.defender.openzeppelin.com/autotasks/b939da27-4a61-4464-8d7e-4b0c5dceb270/runs/webhook/f662ac31-8f56-4b4c-9526-35aea314af63/SPs6smVfv41kLtz4zivxr8\";\n                const forwarder = createInstance(library)\n                const data = deb0xContract.interface.encodeFunctionData(\"claimRewards()\")\n                const to = deb0xContract.address\n\n                try {\n                    const request = await signMetaTxRequest(library, forwarder, { to, from, data });\n\n                    gaEventTracker(\"Success: Claim rewards\");\n        \n                    await fetchClaimRewardsResult(request, url)\n        \n                } catch (error: any) {\n                    setNotificationState({\n                        message: \"You rejected the transaction. Rewards were not claimed.\",\n                        open: true,\n                        severity: \"info\"\n                    })\n\n                    gaEventTracker(\"Rejected: Claim rewards\");\n                }\n            } else {\n                await sendClaimRewardsTx(deb0xContract)\n            }\n        }\n\n        return (\n            <>\n            <Card variant=\"outlined\" className=\"card-container\">\n                <CardContent className=\"row\">\n                    <div className=\"col-12 col-md-10 mb-2\">\n                        <Typography variant=\"h4\" component=\"div\" className=\"rewards mb-3\">\n                            Your rewards\n                        </Typography>\n                        <Typography >\n                            Your unclaimed DXN rewards: <strong>{rewardsUnclaimed}</strong>\n                        </Typography>\n                        <p className='my-2 counter'>\n                            Get next rewards in:\n                        </p>\n                    </div>\n                    <div className='col-12 col-md-2 d-flex justify-content-end align-items-start'>\n                        <img src={finance} alt=\"trophyRewards\" className=\"p-3 medium-img\"/>\n                    </div>\n                </CardContent>\n                <CardActions className='button-container px-3'>\n                    <LoadingButton className=\"collect-btn\" loading={loading} variant=\"contained\" onClick={claimRewards}>Claim</LoadingButton>\n                    <span className=\"text\">Unclaimed DXN is considered automatically staked. Only claim when you want to trade.</span>\n                </CardActions>\n            </Card>\n            </>\n        )\n    }\n\n    function floorPrecised(number:any) {\n        var power = Math.pow(10, 2);\n        return (Math.floor(parseFloat(number) * power) / power).toString();\n    }\n\n    function StakeUnstake() {\n        const [alignment, setAlignment] = useState(\"stake\");\n\n        const [userStakedAmount, setUserStakedAmount] = useState(\"\")\n        const [userUnstakedAmount, setUserUnstakedAmount] = useState(\"\")\n        const [tokensForUnstake, setTokenForUnstake] = useState(\"\");\n        const [totalStaked, setTotalStaked] = useState(\"\")\n        const [amountToUnstake, setAmountToUnstake] = useState(\"\")\n        const [amountToStake, setAmountToStake] = useState(\"\")\n        const [loading, setLoading] = useState(false)\n        const [approved, setApproved] = useState<Boolean | null>(false)\n        \n        const handleChange = (\n            event: React.MouseEvent<HTMLElement>,\n            newAlignment: string,\n        ) => {\n            setAlignment(newAlignment);\n            gaEventTracker(newAlignment + \" tab\");\n        };\n        \n        const [theme, setTheme] = useState(localStorage.getItem('globalTheme'));\n        useEffect(() => {\n            setTheme(localStorage.getItem('globalTheme'));\n        });\n\n        useEffect(() => {\n            setStakedAmount()\n        }, [userStakedAmount]);\n\n        useEffect(() => {\n            totalAmountStaked()\n        }, [totalStaked]);\n\n\n        useEffect(() => {\n            setTokensForUntakedAmount()\n        },[]);\n\n        useEffect(() => {\n            setUnstakedAmount()\n        }, [userUnstakedAmount]);\n\n        useEffect(() => {\n            setApproval()\n        }, [approved]);\n\n        async function setStakedAmount() {\n            const deb0xContract = await DBXen(library, deb0xAddress)\n            const deb0xViewsContract = await DBXenViews(library, deb0xViewsAddress)\n            const balance = await deb0xViewsContract.getAccWithdrawableStake(account)\n            let firstStakeCycle = await deb0xContract.accFirstStake(account)\n            let secondStakeCycle =  await deb0xContract.accSecondStake(account)\n            let firstStakeCycleAmount = await deb0xContract.accStakeCycle(account,firstStakeCycle);\n            let secondStakeCycleAmount = await deb0xContract.accStakeCycle(account,secondStakeCycle);\n            let withdawbleStake = await deb0xContract.accWithdrawableStake(account);\n            let totalStakedAmount = BigNumber.from(firstStakeCycleAmount).add(BigNumber.from(secondStakeCycleAmount)).add(BigNumber.from(withdawbleStake))\n            setUserStakedAmount(ethers.utils.formatEther(totalStakedAmount))\n        }\n\n        async function setTokensForUntakedAmount() {\n            const deb0xViewsContract = await DBXenViews(library, deb0xViewsAddress)\n            const balance = await deb0xViewsContract.getAccWithdrawableStake(account)\n            setTokenForUnstake(ethers.utils.formatEther(balance.toString()));\n        }\n\n        async function setUnstakedAmount() {\n            const deb0xERC20Contract = await DBXenERC20(library, deb0xERC20Address)\n            const balance = await deb0xERC20Contract.balanceOf(account)\n            let number = ethers.utils.formatEther(balance);\n            setUserUnstakedAmount(parseFloat(number.slice(0, (number.indexOf(\".\")) +3)).toString()) \n        }\n\n        async function setApproval() {\n            const deb0xERC20Contract = await DBXenERC20(library, deb0xERC20Address)\n\n            const allowance = await deb0xERC20Contract.allowance(account, deb0xAddress)\n            allowance > 0 ? setApproved(true) : setApproved(false)\n        }\n\n        async function totalAmountStaked() {\n\n            const deb0xContract = await DBXen(library, deb0xAddress)\n\n            const currentCycle = await deb0xContract.currentStartedCycle()\n\n            const totalSupply = await deb0xContract.summedCycleStakes(currentCycle)\n\n            setTotalStaked(ethers.utils.formatEther(totalSupply))\n        }\n\n        async function approveStaking() {\n            setLoading(true)\n\n            const signer = await library.getSigner(0)\n            const deb0xERC20Contract = await DBXenERC20(signer, deb0xERC20Address)\n\n            try {\n                const tx = await deb0xERC20Contract.approve(deb0xAddress, ethers.utils.parseEther(\"5010000\"))\n                tx.wait()\n                    .then((result: any) => {\n                        setNotificationState({\n                            message: \"Your succesfully approved contract for staking.\", open: true,\n                            severity: \"success\"\n                        })\n                        setLoading(false)\n\n                        gaEventTracker(\"Success: Approve staking\");\n\n                    })\n                    .catch((error: any) => {\n                        setNotificationState({\n                            message: \"Contract couldn't be approved for staking!\", open: true,\n                            severity: \"error\"\n                        })\n                        setLoading(false)\n                        gaEventTracker(\"Error: Approve staking\");\n                    })\n            } catch (error) {\n                setNotificationState({\n                    message: \"You rejected the transaction. Contract hasn't been approved for staking.\", open: true,\n                    severity: \"info\"\n                })\n                setLoading(false)\n                gaEventTracker(\"Rejected: Approve staking\");\n            }\n        }\n\n        async function fetchUnstakeResult(request: any, url: any) {\n            await fetch(url, {\n                method: 'POST',\n                body: JSON.stringify(request),\n                headers: { 'Content-Type': 'application/json' },\n            })\n                .then((response) => response.json())\n                .then(async (data) => {\n                    try{\n                        const {tx: txReceipt} = JSON.parse(data.result)\n                        if(txReceipt.status == 1){\n                            setNotificationState({\n                                message: \"Your tokens were succesfully unstaked.\", open: true,\n                                severity: \"success\"\n                            })\n                            setLoading(false)\n                        } else {\n                            setNotificationState({\n                                message: \"Your tokens couldn't be unstaked!\", open: true,\n                                severity: \"error\"\n                            })\n                            setLoading(false)\n                        }\n                    } catch(error) {\n                        if(data.status == \"pending\") {\n                            setNotificationState({\n                                message: \"Your transaction is pending. Your DXN should be unstaked shortly\",\n                                open: true,\n                                severity: \"info\"\n                            })\n                        } else if(data.status == \"error\") {\n                            setNotificationState({\n                                message: \"Transaction relayer error. Please try again\",\n                                open: true,\n                                severity: \"error\"\n                            })\n                            setLoading(false)\n                        }\n                    }\n                    \n                })\n        }\n\n        async function sendUnstakeTx(deb0xContract: any) {\n            try {\n                const tx = await deb0xContract.unstake(ethers.utils.parseEther(amountToUnstake.toString()))\n\n                tx.wait()\n                    .then((result: any) => {\n                        setNotificationState({\n                            message: \"Your tokens were succesfully unstaked.\", open: true,\n                            severity: \"success\"\n                        })\n                        setLoading(false)\n\n                    })\n                    .catch((error: any) => {\n                        setLoading(false)\n                        setNotificationState({\n                            message: \"Your tokens couldn't be unstaked!\", open: true,\n                            severity: \"error\"\n                        })\n\n                    })\n            } catch(error) {\n                setNotificationState({\n                    message: \"You rejected the transaction. Your tokens haven't been unstaked.\",\n                    open: true,\n                    severity: \"info\"\n                })\n                setLoading(false)\n            }\n        }\n\n        async function unstake() {\n            setLoading(true)\n\n            const signer = await library.getSigner(0)\n\n            const deb0xContract = DBXen(signer, deb0xAddress)\n            \n            const from = await signer.getAddress();\n            if(whitelist.includes(from)) {\n                const url = \"https://api.defender.openzeppelin.com/autotasks/b939da27-4a61-4464-8d7e-4b0c5dceb270/runs/webhook/f662ac31-8f56-4b4c-9526-35aea314af63/SPs6smVfv41kLtz4zivxr8\";\n                const forwarder = createInstance(library)\n                const data = deb0xContract.interface.encodeFunctionData(\"unstake\",\n                    [ethers.utils.parseEther(amountToUnstake.toString())])\n                const to = deb0xContract.address\n                try {\n                    const request = await signMetaTxRequest(library, forwarder, { to, from, data });\n\n                    gaEventTracker(\"Success: Unstake\");\n        \n                    await fetchUnstakeResult(request, url)\n        \n                } catch (error: any) {\n                    setNotificationState({\n                        message: \"You rejected the transaction. DXN were not unstaked.\",\n                        open: true,\n                        severity: \"info\"\n                    })\n                    setLoading(false)\n\n                    gaEventTracker(\"Rejected: Unstake\");\n                }\n            } else { \n                await sendUnstakeTx(deb0xContract)\n            }\n        }\n\n        async function fetchStakeResult(request: any, url: any) {\n            await fetch(url, {\n                method: 'POST',\n                body: JSON.stringify(request),\n                headers: { 'Content-Type': 'application/json' },\n            })\n                .then((response) => response.json())\n                .then(async (data) => {\n                    try{\n                        const {tx: txReceipt} = JSON.parse(data.result)\n                        if(txReceipt.status == 1){\n                            setNotificationState({\n                                message: \"You succesfully staked your DXN.\", open: true,\n                                severity: \"success\"\n                            })\n                        } else {\n                            setNotificationState({\n                                message: \"DXN couldn't be claimed!\", open: true,\n                                severity: \"error\"\n                            })\n                            setLoading(false)\n                        }\n                    } catch(error) {\n                        if(data.status == \"pending\") {\n                            setNotificationState({\n                                message: \"Your transaction is pending. Your DXN should be staked shortly\",\n                                open: true,\n                                severity: \"info\"\n                            })\n                        } else if(data.status == \"error\") {\n                            setNotificationState({\n                                message: \"Transaction relayer error. Please try again\",\n                                open: true,\n                                severity: \"error\"\n                            })\n                            setLoading(false)\n                        }\n                    }\n                    \n                })\n        }\n\n        async function sendStakeTx(deb0xContract: any) {\n            try {\n                const tx = await deb0xContract.stake(ethers.utils.parseEther(amountToStake.toString()))\n\n                tx.wait()\n                    .then((result: any) => {\n                        setNotificationState({\n                            message: \"Your tokens were succesfully staked.\", open: true,\n                            severity: \"success\"\n                        })\n                        //setLoading(false)\n\n                    })\n                    .catch((error: any) => {\n                        setNotificationState({\n                            message: \"Your tokens couldn't be staked!\", open: true,\n                            severity: \"error\"\n                        })\n                        setLoading(false)\n                    })\n            } catch(error) {\n                setNotificationState({\n                    message: \"You rejected the transaction. Your tokens haven't been staked.\",\n                    open: true,\n                    severity: \"info\"\n                })\n                setLoading(false)\n            }\n        }\n\n        async function stake() {\n            setLoading(true)\n\n            const signer = await library.getSigner(0)\n\n            const deb0xContract = DBXen(signer, deb0xAddress)\n            \n            const from = await signer.getAddress();\n            if(whitelist.includes(from)){\n                const url = \"https://api.defender.openzeppelin.com/autotasks/b939da27-4a61-4464-8d7e-4b0c5dceb270/runs/webhook/f662ac31-8f56-4b4c-9526-35aea314af63/SPs6smVfv41kLtz4zivxr8\";\n                const forwarder = createInstance(library)\n                const data = deb0xContract.interface.encodeFunctionData(\"stake\",\n                    [ethers.utils.parseEther(amountToStake.toString())])\n                const to = deb0xContract.address\n\n                try {\n                    const request = await signMetaTxRequest(library, forwarder, { to, from, data });\n\n                    gaEventTracker(\"Success: Stake\");\n        \n                    await fetchStakeResult(request, url)\n        \n                } catch (error: any) {\n                    setNotificationState({\n                        message: \"You rejected the transaction. DXN were not staked.\",\n                        open: true,\n                        severity: \"info\"\n                    })\n                    setLoading(false)\n                    gaEventTracker(\"Rejected: Stake\");\n                }\n            } else {\n                await sendStakeTx(deb0xContract)\n            }\n        }\n\n        return (\n            <Card variant = \"outlined\" className=\"card-container\">\n                <ToggleButtonGroup\n                    color=\"primary\"\n                    value={alignment}\n                    exclusive\n                    onChange={handleChange}\n                    className=\"tab-container\"\n                >\n                    <ToggleButton className=\"tab-btn\" value=\"stake\">Stake</ToggleButton>\n                    <ToggleButton className=\"tab-btn\" value=\"unstake\" >Unstake</ToggleButton>\n\n                </ToggleButtonGroup>\n              \n            {\n                alignment === \"stake\" ?\n                \n                <>\n                <CardContent className=\"row\">\n                    <div className=\"col-6 px-3\">\n                        <img className=\"display-element\" src={theme === \"classic\" ? coinBagDark : coinBagLight} alt=\"coinbag\" />\n                        <Typography className=\"p-0\">\n                            Your staked amount:\n                        </Typography>\n                        <Typography variant=\"h6\" className=\"p-0 data-height\">\n                            <strong>{userStakedAmount} DXN</strong>\n                        </Typography>\n                    </div>\n                    <div className=\"col-6 px-3\">\n                        <img className=\"display-element\" src={theme === \"classic\" ? walletDark : walletLight} alt=\"coinbag\" />\n                        <Typography className=\"p-0\">\n                            Available DXN in your wallet:\n                        </Typography>\n                        <Typography variant=\"h6\" className=\"p-0\" data-height>\n                            <strong>{userUnstakedAmount} DXN</strong>\n                        </Typography>\n                    </div>\n                    {approved && <Grid className=\"amount-row px-3\" container>\n                        <Grid item>\n                            <OutlinedInput id=\"outlined-basic\"\n                                placeholder=\"Amount to stake\"\n                                type=\"number\"\n                                value={amountToStake}\n                                inputProps={{ min: 0 }}\n                                onChange={e => setAmountToStake(e.target.value)} />\n                        </Grid>\n                        <Grid className=\"max-btn-container\" item>\n                            <Button className=\"max-btn\" \n                                size=\"small\" variant=\"contained\" color=\"error\" \n                               onClick = {()=>setAmountToStake(userUnstakedAmount)  }>\n                                max\n                            </Button>\n                        </Grid>\n                    </Grid>}\n                </CardContent>\n                <CardActions className='button-container px-3'>\n                    {approved && <LoadingButton disabled={!amountToStake} className=\"collect-btn\" loading={loading} variant=\"contained\" onClick={stake}>Stake</LoadingButton>}\n                    {!approved &&\n                        <>\n                            <LoadingButton \n                                className=\"collect-btn\" \n                                loading={loading}\n                                variant=\"contained\"\n                                disabled={ userUnstakedAmount === '0.00' ||  userUnstakedAmount === '0'}\n                                onClick={approveStaking}>\n                                    Initialize Staking\n                            </LoadingButton>\n                            <span className=\"text\">\n                                Make sure you have DXN tokens in your wallet before you can stake them.\n                            </span>\n                        </> \n                    }\n                </CardActions>\n                </>\n                : \n\n                <>\n                <CardContent className=\"row\">\n                    <div className=\"col-6 px-3\">\n                        <img className=\"display-element\" src={theme === \"classic\" ? coinBagDark : coinBagLight} alt=\"coinbag\" />\n                        <Typography className=\"p-0\">\n                            Available to unstake:\n                        </Typography>\n                        <Typography variant=\"h6\" className=\"p-0\">\n                            <strong>{tokensForUnstake} DXN</strong>\n                        </Typography>\n                    </div>\n                    {/* <div className=\"col-6 px-3\">\n                        <img className=\"display-element\" src={theme === \"classic\" ? walletDark : walletLight} alt=\"coinbag\" />\n                        <Typography className=\"p-0\">\n                            Your actual stake:\n                        </Typography>\n                        <Typography variant=\"h6\" className=\"p-0 data-height\">\n                            <strong>{userStakedAmount} DXN</strong>\n                        </Typography>\n                    </div> */}\n                  \n\n                    <Grid className=\"amount-row px-3\" container>\n                        <Grid item>\n                            <OutlinedInput value={amountToUnstake}\n                                id=\"outlined-basic\"\n                                className=\"max-field\"\n                                placeholder=\"Amount to unstake\"\n                                onChange={e => setAmountToUnstake(e.target.value)}\n                                inputProps={{ min: 0 }}\n                                type=\"number\" />\n                        </Grid>\n                        <Grid className=\"max-btn-container\" item>\n                            <Button className=\"max-btn\"\n                                size=\"small\" variant=\"contained\" color=\"error\" \n                                onClick = {()=>setAmountToUnstake(tokensForUnstake)  }>\n                                max\n                            </Button>\n                        </Grid>\n                    </Grid>\n                </CardContent>\n                <CardActions className='button-container px-3'>\n                    <LoadingButton className=\"collect-btn\" disabled={!amountToUnstake} loading={loading} variant=\"contained\" onClick={unstake}>Unstake</LoadingButton>\n                </CardActions>\n                </>\n            }\n\n            </Card>\n\n        )\n    }\n\n    function TotalStaked() {\n        const [totalStaked, setTotalStaked] = useState(\"\")\n        useEffect(() => {\n            totalAmountStaked()\n        }, [totalStaked]);\n    \n        async function totalAmountStaked() {\n    \n            const deb0xContract = await DBXen(library, deb0xAddress)\n\n            const currentCycle= await deb0xContract.currentStartedCycle()\n\n            const currentStake = await deb0xContract.summedCycleStakes(currentCycle)\n\n            const pendingStakeWithdrawal = await deb0xContract.pendingStakeWithdrawal()\n    \n            // setTotalStaked(ethers.utils.formatEther(currentStake))\n\n            setTotalStaked(floorPrecised(ethers.utils.formatEther(currentStake.sub(pendingStakeWithdrawal))))\n\n        }\n\n        return (\n            <Card className=\"heading-card\">\n                <CardContent>\n                    <Typography variant=\"h5\">\n                        Total tokens staked:\n                    </Typography>\n                    <Typography variant=\"h4\">\n                        <img className=\"logo\" src={token} />\n                        {totalStaked} DXN\n                    </Typography>\n                </CardContent>\n            </Card>\n        )\n    }\n\n    return (\n        <>\n            <SnackbarNotification state={notificationState} setNotificationState={setNotificationState} />\n            <Box className=\"content-box stake-content\">\n                <div className=\"cards-grid\">\n                    <div className='row'>\n                        <Grid item className=\"col col-12 col-md-6 \">\n                            <FeesPanel />\n                        </Grid>\n                        <Grid item className=\"col col-12 col-md-6\">\n                            <CyclePanel />\n                        </Grid>\n                    </div>\n                    <div className='row'>\n                        <Grid item className=\"col col-12 col-md-6 \">\n                            <RewardsPanel />\n                        </Grid>\n                        <Grid item className=\"col col-12 col-md-6\">\n                            <StakeUnstake/>\n                        </Grid>\n                    </div>\n                </div>\n            </Box>\n        </>\n    )\n}","import { createContext } from \"react\";\n\nexport const initialThemeState = {\n  theme: \"dark\",\n  setTheme: (_value: string) => {}\n};\n\nconst ThemeContext = createContext(initialThemeState);\nexport default ThemeContext;","import { useState, useEffect } from \"react\";\nimport ThemeContext, { initialThemeState } from \"./ThemeContext\";\n\ntype Props = {\n    children: JSX.Element|JSX.Element[],\n};\n\nconst ThemeProvider = ( { children }: Props ) => {\n  const [theme, setTheme] = useState<any>(initialThemeState.theme);\n\n  const localStorage = window.localStorage;\n\n  useEffect(() => {\n    const savedThemeLocal = localStorage.getItem(\"globalTheme\");\n\n    if (!!savedThemeLocal) {\n      setTheme(savedThemeLocal);\n    }\n  }, [localStorage]);\n\n  useEffect(() => {\n    localStorage.setItem(\"globalTheme\", theme);\n  }, [theme, localStorage]);\n\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      <div className={`theme theme--${theme}`}>{children}</div>\n    </ThemeContext.Provider>\n  );\n};\n\nexport default ThemeProvider;\n","export default __webpack_public_path__ + \"static/media/elephant.b785cc48.png\";","export default __webpack_public_path__ + \"static/media/elephant.605d60c2.svg\";","export default __webpack_public_path__ + \"static/media/white_dbxen.8b09777a.svg\";","export default __webpack_public_path__ + \"static/media/empty.efc45323.png\";","import { useEffect, useState } from 'react';\nimport Box from '@mui/material/Box';\nimport Button from '@mui/material/Button';\nimport { injected } from '../../connectors';\nimport { useWeb3React } from '@web3-react/core';\nimport { Spinner } from './Spinner';\nimport { ethers } from 'ethers';\nimport formatAccountName from '../Common/AccountName';\nimport DBXen from \"../../ethereum/dbxen\"\nimport DBXenViews from \"../../ethereum/dbxenViews\";\nimport DBXenERC20 from \"../../ethereum/dbxenerc20\"\nimport Popper from '@mui/material/Popper';\nimport ClickAwayListener from '@mui/base/ClickAwayListener';\nimport '../../componentsStyling/appBar.scss';\nimport copyIcon from '../../photos/icons/copy-1.svg';\nimport walletIcon from '../../photos/icons/wallet.svg';\nimport disconnectIcon from '../../photos/icons/diconnect.svg';\nimport logo from \"../../photos/white_dbxen.svg\";\n\nconst deb0xAddress = \"0XBC7FB353CCEB4DCAD1DEA187BC443EACA3360B76\";\nconst deb0xViewsAddress = \"0X07F38CCDDC4ADE1D0EA6DC97AB0687470CC1CB15\";\nconst deb0xERC20Address = \"0X196383703B9910F38E25528858E67E63362AD68A\"\nconst tokenSymbol = 'DBXen';\n\nconst tokenDecimals = 18;\nenum ConnectorNames { Injected = 'Injected' };\n\nconst connectorsByName: { [connectorName in ConnectorNames]: any } = {\n    [ConnectorNames.Injected]: injected\n}\n\nexport function AppBarComponent(props: any): any {\n    const context = useWeb3React();\n    const { connector, library, chainId, account, activate, deactivate } = context\n    const [activatingConnector, setActivatingConnector] = useState<any>();\n    const [networkName, setNetworkName] = useState<any>();\n    const [userUnstakedAmount,setUserUnstakedAmount] = useState<any>(0);\n    const [ensName, setEnsName] = useState<any>(\"\");\n    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n    const [, setNotificationState] = useState({})\n    const [theme, setTheme] = useState(localStorage.getItem('globalTheme'));\n    const [userStakedAmount, setUserStakedAmount] = useState(\"\")\n    const [rewardsUnclaimed, setRewardsUnclaimed] = useState(\"\")\n    const [open, setOpen] = useState<any>();\n    const deb0xViewsContract = DBXenViews(library, deb0xViewsAddress)\n    const [totalStaked, setTotalStaked] = useState(\"\")\n    const [totalXENBurned, setTotalXENBurned] = useState<any>();\n\n    const id = open ? 'simple-popper' : undefined;\n\n    if(library){\n        checkENS();\n        setUnstakedAmount();\n    }\n\n    useEffect(() => {\n        totalAmountStaked()\n    }, [totalAmountStaked]);\n\n    useEffect(() => {\n        setTheme(localStorage.getItem('globalTheme'));\n    }, []);\n\n    useEffect(() => {\n        injected.supportedChainIds?.forEach(chainId => \n            setNetworkName((ethers.providers.getNetwork(chainId).name)));\n        if (activatingConnector && activatingConnector === connector) {\n            setActivatingConnector(undefined)\n        }\n    }, [activatingConnector, connector]);\n\n    useEffect(() => {\n        const totalXenBurned = async () =>{\n            setTotalXENBurned(await getTotalXenBurned())\n        }\n        totalXenBurned();\n    },[]);\n\n    async function getTotalXenBurned(){\n        const signer = await library.getSigner(0)\n        const deb0xContract = DBXen(signer, deb0xAddress)\n        let numberBatchesBurnedInCurrentCycle = await deb0xContract.totalNumberOfBatchesBurned();\n        let batchBurned =numberBatchesBurnedInCurrentCycle.toNumber();\n        return batchBurned * 2500000;\n    }\n\n    async function setUnstakedAmount() {\n        const deb0xERC20Contract = DBXenERC20(library, deb0xERC20Address)\n        if(account){\n            await deb0xERC20Contract.balanceOf(account).then((result: any) => \n                setUserUnstakedAmount(floorPrecised(ethers.utils.formatEther(result)))\n            )\n        }\n    }\n\n    useEffect(() => {\n        const deb0xERC20Contract = DBXenERC20(library, deb0xERC20Address)\n        const filterFrom = deb0xERC20Contract.filters.Transfer(account)\n        const filterTo =  deb0xERC20Contract.filters.Transfer(null, account)\n        deb0xERC20Contract.on(filterFrom, () => {\n            setUnstakedAmount()\n        })\n        deb0xERC20Contract.on(filterTo, () => {\n            setUnstakedAmount()\n        })\n\n        return () => {\n            deb0xERC20Contract.removeAllListeners()\n        }\n    },[])\n\n    async function checkENS(){\n        if(chainId !== 137){\n            var name = await library.lookupAddress(account);\n            if(name !== null)\n            {   \n                setEnsName(name);\n            }\n        }\n       \n    }\n\n    function floorPrecised(number:any) {\n        var power = Math.pow(10, 2);\n        return (Math.floor(parseFloat(number) * power) / power).toString();\n    }\n\n    async function totalAmountStaked() {\n        const deb0xContract = DBXen(library, deb0xAddress)\n        const currentCycle= await deb0xContract.currentStartedCycle()\n        const currentStake = await deb0xContract.summedCycleStakes(currentCycle)\n        const pendingStakeWithdrawal = await deb0xContract.pendingStakeWithdrawal()\n        setTotalStaked(floorPrecised(ethers.utils.formatEther(currentStake.sub(pendingStakeWithdrawal))))\n    }\n\n    async function addToken() {\n        try {\n            const wasAdded = await window.ethereum.request({\n              method: 'wallet_watchAsset',\n              params: {\n                type: 'ERC20',\n                options: {\n                  address: deb0xERC20Address,\n                  symbol: tokenSymbol,\n                  decimals: tokenDecimals,\n                //   image: tokenImage,\n                },\n              },\n            });\n\n            if (wasAdded) {\n                setNotificationState({\n                    message: \"The token was added in your wallet\",\n                    open: true,\n                    severity: \"success\"\n                })      \n                setOpen(false)      \n            }\n            } catch (error: any) {\n                setNotificationState({\n                    message: \"There was an error. Try again later\",\n                    open: true,\n                    severity: \"info\"\n                })\n            }\n    }\n\n    function copyWalletID() {\n        if(account) {\n            navigator.clipboard.writeText(account)\n            setNotificationState({\n                message: \"The address ID was copied successfully\",\n                open: true,\n                severity: \"success\"\n            })\n        }\n        setOpen(false)\n        \n    }\n\n    async function rewardsAccrued() {\n        await deb0xViewsContract.getUnclaimedRewards(account).then((result: any) => \n            setRewardsUnclaimed(floorPrecised(ethers.utils.formatEther(result)))\n        )\n    }\n\n    async function setStakedAmount() {\n        await deb0xViewsContract.getAccWithdrawableStake(account).then((result: any) => \n            setUserStakedAmount(floorPrecised(ethers.utils.formatEther(result)))\n        )\n    }\n\n    const handleClick = (event: any) => {\n        rewardsAccrued();\n        setStakedAmount();\n        setUnstakedAmount();\n        const { currentTarget } = event;\n        setAnchorEl(currentTarget)\n        setOpen(!open)\n      };\n\n    const handleClickAway = () => {\n        setOpen(false)\n    };\n    \n    return (\n        <ClickAwayListener onClickAway={handleClickAway}>\n            <div>\n                <div className=\"app-bar--top\">\n                    <img className=\"logo\" src={logo} alt=\"logo\" />\n                    <Box className=\"main-menu--left\">\n                        <p className=\"mb-0\">Total tokens staked: {totalStaked} DXN</p>\n                        <p className=\"mb-0\">\n                            Total XEN burned: {totalXENBurned}\n                        </p>\n                    </Box>\n                    <Box className=\"main-menu--right\">\n                    \n                    { (() =>  {\n                        const currentConnector = connectorsByName[ConnectorNames.Injected]\n                        const activating = currentConnector === activatingConnector\n                        const connected = currentConnector === connector\n\n                        return (\n                            <Button variant=\"contained\"\n                                key={ConnectorNames.Injected}\n                                aria-describedby={id}\n                                onClick={!connected ? \n                                    () => {\n                                        setActivatingConnector(currentConnector)\n                                        activate(currentConnector)\n                                    } : \n                                    handleClick\n                                }>\n                                \n                                { activating ? \n                                    <Spinner color={'black'} /> :\n                                    !connected ? \n                                        \"Connect Wallet\" :\n                                        <span>\n                                            {account === undefined ? \n                                                `Unsupported Network. Switch to ${networkName}` : \n                                                account ? \n                                                    ensName === \"\" ? \n                                                        `${formatAccountName(account)}` :\n                                                        `${ensName.toLowerCase()} \n                                                        (${formatAccountName(account)})`\n                                                : ''}\n                                        </span>\n                                }\n                            </Button>\n                        )\n                    }) ()}\n                    </Box>\n                </div>\n                <Popper className={`popper ${theme === \"classic\" ? \"classic\" : \"dark\"}` } id={id} open={open} anchorEl={anchorEl}>\n                    <ul>\n                        <li>\n                            Unclaimed rewards: <br/> \n                            <b>{rewardsUnclaimed} <span>DXN</span></b>\n                        </li>\n                        <li>\n                            Active stake: <br/> \n                            <b>{userStakedAmount} <span>DXN</span></b>\n                        </li>\n                        <li>\n                            In wallet: <br/> \n                            <b>{userUnstakedAmount} <span>DXN</span></b>\n                        </li>\n                    </ul>\n                    <Button \n                        onClick={(event: any) => {\n                            copyWalletID()\n                        }}\n                        className=\"copy-wallet-btn\">\n                        <span><img src={copyIcon} alt=\"copy\" /></span>Copy wallet ID\n                    </Button>\n                    <Button\n                        onClick={(event: any) => {\n                            addToken()\n                        }}\n                        className=\"add-token-btn\">\n                         <span><img src={walletIcon} alt=\"wallet\"/></span>Add token to wallet\n                    </Button>\n                    <Button \n                        onClick={(event: any) => {\n                            handleClick(event)\n                            deactivate()\n                        }}\n                            className=\"logout-btn\">\n                             <span><img src={disconnectIcon} alt=\"disconnect\"/></span>Disconnect wallet\n                    </Button>  \n\n                </Popper>\n            </div>\n        </ClickAwayListener>\n    );\n}\n","export default __webpack_public_path__ + \"static/media/copy-1.6be37e8f.svg\";","export default __webpack_public_path__ + \"static/media/wallet.0d69376a.svg\";","export default __webpack_public_path__ + \"static/media/diconnect.a287fc1c.svg\";","import { useState, useEffect } from 'react';\nimport './App.css';\nimport { \n    Web3ReactProvider,\n    useWeb3React\n} from '@web3-react/core';\nimport { ethers } from \"ethers\";\nimport { useEagerConnect, useInactiveListener } from './hooks'\nimport { PermanentDrawer } from './components/App/PermanentDrawer'\nimport { Stake } from './components/App/Stake';\nimport { Box, Button } from '@mui/material';\nimport ThemeProvider from './components/Contexts/ThemeProvider';\nimport './index.scss';\nimport { injected, network } from './connectors';\nimport elephant from './photos/icons/elephant.svg';\nimport elephantWithText from './photos/icons/elephant.png';\nimport deb0xen from './photos/white_dbxen.svg';\nimport maintenanceImg from './photos/empty.png';\nimport { Spinner } from './components/App/Spinner';\nimport { AppBarComponent } from './components/App/AppBar';\nimport { Burn } from './components/App/Burn';\nimport ScreenSize from './components/Common/ScreenSize';\nimport Countdown, { zeroPad } from \"react-countdown\";\n\nconst maintenance = process.env.REACT_APP_MAINTENANCE_MODE;\n\n\nenum ConnectorNames { Injected = 'Injected', Network = 'Network' };\n\nconst connectorsByName: { [connectorName in ConnectorNames]: any } = {\n  [ConnectorNames.Injected]: injected,\n  [ConnectorNames.Network]: network\n}\n\nfunction getLibrary(provider: any): ethers.providers.Web3Provider {\n  const library = new ethers.providers.Web3Provider(provider)\n\n  library.pollingInterval = 12000\n  return library\n}\n\nexport default function web3App(): any {\n    const date:any = new Date(Date.UTC(2023, 2, 16, 13, 55, 0, 0));\n    const now: any = Date.now()\n    let endDate = date.getTime() - now\n\n  return (\n        <Web3ReactProvider getLibrary={getLibrary}>\n            <Countdown date={Date.now() + endDate} renderer={renderer} />\n            {/* <App /> */}\n        </Web3ReactProvider>\n    )\n}\n\nconst renderer = ({ hours, minutes, seconds, completed }: any) => {\n    if (completed) {\n      // Render a complete state\n      return <ContractsDeployed />;\n    } else {\n      // Render a countdown\n      return (\n        <ThemeProvider>\n            <div className=\"app-container p-0 \">\n                <div className=\"initial-page contracts\">\n                    <div className=\"row\">\n                        <div className=\"col-12 img-container mr-4\">\n                            <p>DBXen time in:</p>\n                            <p>\n                                {zeroPad(hours)}:{zeroPad(minutes)}:{zeroPad(seconds)}\n                            </p>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </ThemeProvider>\n      );\n    }\n};\n\nfunction ContractsDeployed() {\n    return (\n        <ThemeProvider>\n            <div className=\"app-container p-0 \">\n                <div className=\"initial-page contracts\">\n                    <div className=\"row\">\n                        <div className=\"col-12 img-container mr-4\">\n                            <img className=\"image--left\" src={elephantWithText} alt=\"elephant\" />\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </ThemeProvider>\n    )\n}\n\nfunction App() {\n    const context = useWeb3React<ethers.providers.Web3Provider>()\n    const { connector, account, activate } = context\n    const [selectedIndex, setSelectedIndex] = useState<any>(0);\n    // handle logic to recognize the connector currently being activated\n    const [activatingConnector, setActivatingConnector] = useState<any>()\n    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);\n    const [networkName, setNetworkName] = useState<any>();\n    let errorMsg;\n    const dimensions = ScreenSize();\n    \n    useEffect(() => {\n        injected.supportedChainIds?.forEach(chainId => \n            setNetworkName((ethers.providers.getNetwork(chainId).name)));\n        if (activatingConnector && activatingConnector === connector) {\n            setActivatingConnector(undefined)\n        }\n    }, [activatingConnector, connector])\n\n    // handle logic to eagerly connect to the injected ethereum provider, if it exists and has granted access already\n    const triedEager = useEagerConnect()\n\n    // handle logic to connect in reaction to certain events on the injected ethereum provider, if it exists\n    useInactiveListener(!triedEager || !!activatingConnector)\n\n    function handleClick (event: React.MouseEvent<HTMLElement>) {\n        setAnchorEl(anchorEl ? null : event.currentTarget);\n    };\n\n    useEffect(() => {   \n        window.ethereum ?\n            window.ethereum.request({method: \"eth_requestAccounts\"}).then(() => {\n                switchNetwork();               \n            }).catch((err: any) => displayErrorMsg(err))\n            : displayErrorMsg(\"Please install MetaMask\")\n        }, [])\n\n    async function switchNetwork() {\n        try {\n            await window.ethereum.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: \"0x89\"}],\n            }).then(\n                displayErrorMsg(\"You have switched to the right network\")\n            );            \n        } catch (switchError) {\n            try {\n                await window.ethereum.request({\n                method: 'wallet_addEthereumChain',\n                params: [\n                    {\n                        chainId: '0x89', \n                        chainName:'Polygon Network',\n                        rpcUrls:['https://rpc-mainnet.maticvigil.com'],                   \n                        blockExplorerUrls:['https://polygonscan.com/'],  \n                        nativeCurrency: { \n                        symbol:'Matic',   \n                        decimals: 18\n                        }       \n                    }\n                    ]});\n            } catch (err) {\n                displayErrorMsg(\"Cannot switch to the network\");\n            }\n        }\n        \n    }\n\n    function displayErrorMsg(error: string) {\n        errorMsg = error;\n        return errorMsg;\n    }\n    \n    return (\n\n    <>\n    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n        {!!errorMsg &&\n            <p className='alert alert-danger position-fixed' style={{ marginTop: '4rem', marginBottom: '0' }}>\n                {displayErrorMsg(errorMsg)}\n            </p>\n        }\n    </div>\n        <ThemeProvider>\n        { account ? \n            <div className=\"app-container container-fluid\">\n                { maintenance === \"true\" ?\n                    <div className=\"row main-row maintenance-mode\">\n                        <img className=\"maintenance-img\" src={maintenanceImg} alt=\"maintenance\" />\n                        <h1>Maintenance Mode</h1>\n                        <h4>We're tightening some nuts and bolts round the back. We'll be back up and running soon.</h4>\n                    </div> :\n                    <div className=\"row main-row\">\n                        <div className=\"col col-lg-3 col-12 p-0 side-menu-container\">\n                            <PermanentDrawer />\n                        </div>\n                        <div className=\"col col-lg-9 col-12\">\n                            <AppBarComponent />\n                            \n                            <Box className=\"main-container\" sx={{marginTop: 12}}>\n                            {dimensions.width > 768 ? \n                                <Stake /> :\n                                <>\n                                    {selectedIndex === 0 && <Burn /> }\n                                    {selectedIndex === 1 && <Stake /> }\n                                </>\n                            }\n                            </Box>\n                        </div>\n                    </div>\n                }\n                <div className=\"navigation-mobile\">\n                    <div className={`navigation-item ${selectedIndex === 0 ? \"active\" : \"\"}`}\n                        onClick={() => setSelectedIndex(0)}>\n                            Mint\n                    </div>\n                    <div className={`navigation-item ${selectedIndex === 1 ? \"active\" : \"\"}`}\n                        onClick={() => setSelectedIndex(1)}>\n                            Fees\n                    </div>\n                </div>\n            </div> :\n            <div className=\"app-container p-0 \">\n                <div className=\"initial-page\">\n                    <div className=\"row\">\n                        <div className=\"col-lg-7 img-container mr-4\">\n                            <img className=\"image--left\" src={elephant} alt=\"elephant\" />\n                            <div className=\"img-content\">\n                                <p>Connect your wallet</p>\n                                <p>Burn $XEN</p>\n                                <p>Earn crypto</p>\n                                  \n                                <div>\n                                    { (() =>  {\n                                        const currentConnector = connectorsByName[ConnectorNames.Injected]\n                                        const activating = currentConnector === activatingConnector\n                                        const connected = currentConnector === connector\n\n                                        return (\n                                            <Button variant=\"contained\"\n                                                key={ConnectorNames.Injected}\n                                                // aria-describedby={id}\n                                                onClick={!connected ? \n                                                    () => {\n                                                        setActivatingConnector(currentConnector)\n                                                        activate(currentConnector)\n                                                    } : \n                                                    handleClick}\n                                                    className=\"connect-button\">\n                                                \n                                                { activating ? \n                                                    <Spinner color={'black'} /> :\n                                                    !connected ? \n                                                        \"Connect\" :\n                                                        <span>\n                                                            {typeof window.ethereum === 'undefined' ? \n                                                                `Check your prerequisites` : \n                                                                account === undefined ? `Unsupported Network. Switch to ${networkName}` : ''}\n                                                        </span>\n                                                }\n                                            </Button>\n                                        )\n                                    }) ()}\n                                </div>\n                            </div>\n                        </div>\n                        <div className=\"col-12 col-lg-5 text-center\">\n                            <div className=\"text-container\">\n                                <img className=\"dark-logo\" src={deb0xen} alt=\"logo\" />\n                                <p>\n                                    Community built crypto protocol <br/> contributing to XEN deflation\n                                </p>\n                                <div className=\"connect-mobile\">\n                                    { (() =>  {\n                                        const currentConnector = connectorsByName[ConnectorNames.Injected]\n                                        const activating = currentConnector === activatingConnector\n                                        const connected = currentConnector === connector\n\n                                        return (\n                                            <Button variant=\"contained\"\n                                                key={ConnectorNames.Injected}\n                                                // aria-describedby={id}\n                                                onClick={!connected ? \n                                                    () => {\n                                                        setActivatingConnector(currentConnector)\n                                                        activate(currentConnector)\n                                                    } : \n                                                    handleClick}\n                                                    className=\"connect-button\">\n                                                \n                                                { activating ? \n                                                    <Spinner color={'black'} /> :\n                                                    !connected ? \n                                                        \"Connect\" :\n                                                        <span>\n                                                            {typeof window.ethereum === 'undefined' ? \n                                                                `Check your prerequisites` : \n                                                                account === undefined ? `Unsupported Network. Switch to ${networkName}` : ''}\n                                                        </span>\n                                                }\n                                            </Button>\n                                        )\n                                    }) ()}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        }\n        </ThemeProvider>\n    </>\n  )\n}\n\n\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport 'bootstrap/dist/css/bootstrap.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}